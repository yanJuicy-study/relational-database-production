# 01 SQL과 관계형 모델

관계형 모델은 집합론과 관련지을 수 있다.

릴레이션은 집합에 해당하고, 릴레이션의 연산은 집합에서 사용하는 연산을 사용한다.

## SQL이란

SQL은 RDB에 질의를 하기 위한 언어다.

관계형 모델이 SQL의 기반이 된다는 것은 사실이다.

하지만 SQL을 본다고 관계형 모델이 어떤 것인지는 알 수 없다.

### 관계형 모델을 모르더라도 SQL을 쓸 수 있다?

SQL을 오래 쓰다보면 관계형 모델을 몰라도 불편함 없이 쓸 수 있다.

관계형 모델에 대한 지식이 부족하면 언젠가는 벽에 부딛히는 날이 온다.

그러므로 SQL을 어느 정도 알고 있으면 관계형 모델에 관해서 공부하자.

### RDB는 관계형 모델을 바르게 구현할수록 더욱 진가를 발휘한다!

왜 관계형 모델에 관해서 알아야만 하는 것일까?

SQL은 관계형 모델을 기반으로 한 언어지만 관계형 모델을 충실하게 재현하지는 않는다.

SQL은 유연성이 높게 설계된 언어여서 관계형 모델에 맞게 사용할 수도 있지만, 반대로 전혀 다르게 사용할 수도 있다.

관계형 모델을 모른다면 관계형 모델에서 벗어나고 있는지조차도 판단할 수 없다.

## 관계형 모델

관계형 모델은 실제 세계의 데이터를 “관계” 라는 개념을 사용해 표현한 데이터 모델이다.

ERD와 관계형 모델은 아무런 관계가 없다.

관계형 모델이 나타내는 의미는 “데이터를 어떻게 표현할까” 라는 개념의 의미다.

- OO 라는 개념을 사용해 데이터를 표현해 주세요.
- 최근에는 KVS(Key-Value Store)가 많이 사용되는데, KVS도 데이터 모델의 하나다.

관계형 모델을 이해하는 데 가장 중요한 개념이 관계(릴레이션)다.

### 릴레이션(관계)의 정의

릴레이션에 대한 “일반적인 실수는 테이블 사이의 관계 라고 생각하는 것”이다.

SQL에 있어 릴레이션에 해당하는 것은 테이블이다.

관계형 모델에서 릴레이션이 정의는 다음과 같다.

- 릴레이션은 제목(Heading)과 본체(Body)로 구성돼 있다.
- 제목은 속성(attribute)이 n개 모인 집합이며, 이 속성은 이름과 데이터 형으로 되어 있다.
- 본체는 속성값의 집합인 행 또는 영어로 튜플(tuple)의 집합이다.
- 튜플에 포함된 속성값은 이름과 데이터 형이 제목에서 지정한 것과 서로 일치하지 않으면 안된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8f7a668d-1204-4ce5-ae14-e04e35ddcfd3/Untitled.png)

### 집합이란

집합은 물건의 모임을 표현하는 개념이다.

집합에 포함된 물건을 요소나 원소라고 한다.

집합의 요소는 어떤 성질이든 상관없지만 충족해야할 조건이 몇 가지 있다.

1. 어떤 요소가 집합에 포함돼 있는지 불확정한 요소 없이 판정할 수 있어야 한다.
    - 숫자로 이뤄진 집합 N에는 1이라는 숫자가 포함돼 있는지 판단할 수 있어야 한다.
2. 집합의 요소는 중복돼서는 안 된다.
    - 집합에서 중요한 것은 어떤 요소가 포함돼 있는가 아니냐는 점이다.
3. 집합의 요소는 더는 분해될 수 없다
    - 요소는 요소 하나로서 의미가 있는 값이다.
    - 요소 e가 집합 S에 포함돼 있는지 아닌지는 e 자체와 비교해서 판정할 수 있다.
    - e를 분해한 일부는 e와는 일치하지 않으므로 e가 집합 S에 포함되는 판정에 아무런 영향을 미치지 않는다.

### 관계형 모델과 NULL

집합은 알 수 없는 것을 포함하지 않는다. 즉 집합의 한 종류인 릴레이션에 NULL을 포함할 수 없다.

NULL은 값이 아니라 요소가 무엇인지 모르는, 알 수 없는 값임을 나타내는 표식이다. 

관계형 모델을 올바르게 구현하려면 NULL은 배제해야 한다.

### 유한집합과 무한집합

관계형 모델이 다루는 것은 유한집합뿐이다. 

컴퓨터로 표현할 수 있는 것은 어떤 종류이든 유한이다.

### 릴레이션의 연산

데이터를 릴레이션이라고 표현한다면 그에 대한 연산은 쿼리다.

관계형 모델은 릴레이션 단위로 다양한 연산을 사용해 질의를 수행하는 데이터 모델이다.

릴레이션을 사용한 연산을 수행하므로 관계형 모델이라고 부른다.

대표적인 릴레이션 연산들은 다음과 같다.

1. 제한(Restirct)
    - 릴레이션들 중에 특정 조건에 맞는 튜플을 포함한 릴레이션을 반환
    
    ```sql
    select d where
    ```
    
2. 프로젝션(Projection)
    - 릴레이션의 특정 속성만 포함하는 릴레이션만 반환
    
    ```sql
    select a, b, c
    ```
    
3. 확장(Extend)
    - 속성을 늘리는 동작
    - 대부분 새로운 속성값은 기존의 속성값을 이용해 계산
    
    ```sql
    select a, b, a + b as sum
    ```
    
4. 속성명 변경(Rename)
    - 속성의 이름 변경
    - 주로 확장한 속성에 대해 명칭을 부여할 때 많이 사용
5. 합집합(Union)
    - 두 개의 릴레이션에 포함된 모든 튜플로 구성된 릴레이션(합집합)을 반환
    - 합집합은 중복 값이 제거된 상태
6. 교집합(Intersect)
    - 두 개의 릴레이션에 공통 부분 릴레이션 반환
7. 차집합(Difference)
    - 두 개의 릴레이션 중에 한쪽의 릴레이션에만 포함되어 있는 튜플로 구성된 릴레이션 반환
    - 기준이 되는 릴레이션에 따라 결과가 달라짐
8. 곱집합(Product)
    - 두 개의 릴레이션에 있는 튜플을 각각 조합한 릴레이션 반환
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5bd52dd9-15f6-4e10-90c0-99f9877704f3/Untitled.png)
    
9. 결합 (Join)
    - 공통된 속성을 가진 두 개의 릴레이션에서 공통된 속성값이 같은 튜플끼리 조합된 릴레이션 반환
    

### 클로저(closure)라는 성질

관계형 모델에서 중요한 것은 릴레이션을 사용한 연산 결과가 릴레이션이 되는 것이다.

- 절차형 언어에서 두 정수를 사용한 연산은 정수가 되는 것을 보장한다.
- 두 개의 릴레이션의 합잡합에 다른 릴레이션을 결합하고 그 결과에 제한을 적용하건, 프로젝션을 적용하거나, 다른 릴레이션과 합집합을 연산해도 릴레이션이 나온다.

이처럼 연산의 입력과 출력이 같은 데이터 구조를 가진 성질을 클로저라고 한다.

### 도메인이란

관계형 모델에서 데이터 형식(int, varchar)은 도메인이라고 한다.

집합의 요소(값)에는 변화가 없지만 어떤 요소를 선택할 것인가(변수)는 시시각각 변한다.

그 집합 전체를 도메인이라고 한다.

### SELECT의 기본형

SELECT는 SQL에서 데이터를 조회하는 데 사용하는 유일한 명령어

SELECT는 다음과 같은 구문으로 되어 있다.

```sql
SELECT 칼럼의 목록
FROM 테이블의 목록
WHERE 검색 조건
```

칼럼의 목록은 프로젝션(projection), 테이블의 목록은 곱집합(product), 검색조건은 제한(restrict)이다.

간단한 SELECT는 세 개의 릴레이션 연산을 동시에 수행하는 작업이다.

SELECT에서는 세 가지의 릴레이션 연산이 다음 순서로 평간된다.

1. 테이블의 목록 (곱집합)
2. 검색 조건 (제한)
3. 칼럼의 목록 (프로젝션)

하지만 실제로는 RDB에서는 옵티마이저가 최적화를 실시해 처리를 생략하거나 실행 순서를 바꾼다.

위에서 말하는 SELECT의 순서는 논리적인 의미라는 것을 기억하자.

### INSRET (삽입)

관계형 모델에는 갱신이라는 개념이 존재하지 않는다. 

릴레이션은 값이기 때문에 갱신이 불가능하다.

값을 갱신하는 것이 아니라 릴레이션을 저장하는 변수 Relvar라는 변수를 갱신한다.

SQL에서 테이블의 갱신 처리는 Relvar의 역할로 테이블에 할당된 릴레이션의 값을 변경하는 것이다.

INSERT는 Relvar의 값을 해당 릴레이션에 새롭게 INSER 할 튜플을 추가하고 릴레이션과 바꾸는 작업이다.

```sql
R := R U { T }
# Relvar을 R, 새롭게 삽입된 행에 대한 튜플 T
```

### DELETE

DELETE는 차집합이다.

```sql
DELETE FROM t WHERE c1 = 100;

R := R - { T }
```

전체 릴레이션에서 WHERE 절의 조건에 해당하는 튜플의 집합과의 차집합을 Relvar에 대입하는 것과 같다.

### UPDATE

```sql
UPDATE t SET c1 = 1 WHERE c2 = 123;

R := (R - { T1 }) U { T2 }
# T1은 WHERE 절의 조건에 해당하는 릴레이션, T1에 수정을 가한 릴레이션을 T2
```

릴레이션, 값 자체는 갱신할 수 없으므로 튜플의 값을 바꾼다는 것은 관계형 모델에서는 틀린 말이다.

UPDATE는 다음과 같은 작업이다.

1. 전체 릴레이션에서 WHERE 절의 조건에 맞는 튜플로 이뤄진 릴레이션의 차집합을 구한다.
2. 1의 결과인 릴레이션에 수정을 가한 릴레이션과의 합집합을 구한다.
3. 2의 합집합을 Relvar에 대입한다.

## SQL에는 있고 관계형 모델에는 없는 것

SQL을 효과적으로 사용하기 위한 요령은 관계형 모델에 맞게 사용하는 것이다.

따라서 SQL과 관계형 모델의 차이에 관해서도 잘 이해해야 한다.

### 요소의 중복

릴레이션은 구조가 같은 튜플의 집합이다. 집합은 중복되지 않으므로 릴레이션도 마찬가지다.

하지만 SQL은 테이블에 같은 행이 있더라도 괜찮다.

기본키와 같은 유일성 제약이 있다면 테이블에 중복되는 행이 존재하지 않지만, 아무런 제약이 없다면 중복된 행이 있더라도 SQL 상에 오류가 아니다.

SQL을 관계형 모델에 맞게 사용하려면 테이블을 집합처럼 사용해야 한다.

적어도 어딘가에 유일성 제약이 있어야 한다.

### 요소 사이의 순서

집합은 요소 사이의 순서가 없다. 따라서 집합으로 정의된 릴레이션, 튜플, 제목에 포함된 요소에는 순서가 없다.

하지만 SQL에는 순서가 있다. 칼럼은 정이된 순서대로 나열되고 행을 정렬할 수도 있다.

관계형 모델에 따라 SQL을 사용하려면 행이나 칼럼의 위치를 고려한 쿼리를 작성하면 안된다.

- ROWNUM이나 ORDER BY 1과 같은 기능을 피해야 한다.
- JDBC의 getString 같은 곳에서 칼럼의 위치를 지정해 데이터를 가져오는 API를 사용하면 안된다.

### 릴레이션의 갱신

릴레이션은 값이므로 갱신할 수 없다. 값을 갱신할 수 있는 것은 변수뿐이다.

중요한 점은 테이블이 값과 변수의 기능을 모두 겸한다는 점이다.

### 트랜잭션

트랜잭션은 SQL 사양의 일부이지만, 사실은 관계형 모델과는 다른 독립적인 개념으로 관계형 모델에 포함되지 않는다.

관계형 모델과 트랜잭션은 다른 개념이지만 RDB를 사용하려면 양쪽을 바르게 이해하고 사용해야 한다.

### 스토어드 프로시저

관계형 모델에는 프로시저가 존재하지 않는다. 따라서 커서를 루프로 처리하는 작업은 관계형 모델에서는 없다.

테이블 루프로 처리하는 것은 집합 연산을 정면으로 부정하는 행위다.

[참조](https://spiderwebcoding.tistory.com/7)

### NULL

집합에는 NULL이라는 개념이 없다. 단지 요소가 포함돼 있을 뿐이다.

NULL은 집합에 포함될 수 없다.

SQL을 올바르게 관계형 모델에 맞게 사용하는 데 있어서 NULL 처리는 매우 중요하다.
